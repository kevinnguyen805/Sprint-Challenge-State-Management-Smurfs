1. What problem does the context API help solve?
1. In your own words, describe `actions`, `reducers` and the `store` and their role in Redux. What does each piece do? Why is the store known as a 'single source of truth' in a redux application?
1. What is the difference between Application state and Component state? When would be a good time to use one over the other?
1. Describe `redux-thunk`, what does it allow us to do? How does it change our `action-creators`?
1. What is your favorite state management system you've learned and this sprint? Please explain why!


1. Context API prevents developers from having to pass down props/state through several levels of components. By wrapping the entire component “branch” or “tree”, developers may access state in child components without prop drilling. 
2. There are three types of actions: action creators, action types, and actions. Plain actions are objects that convey info of what the reducer is going to do (type property) and occasionally have data info (payload property) to update state. Action types are variables that capture a string value of the type property, and are maintained as variables to detect for errors. Action creators dispatch actions to reducers upon an event in the UI. Reducers are pure functions that allow developers to confidently predict what will happen to state upon dispatched actions. The store in Redux is where all state within the App is centralized, hence why it is called the “single source of truth”. It allows developers to keep track of state changes in one place. 
3. The difference between an Application state and Component state is the accessibility of state. Application state is global, therefore any component within the component tree may access the state, while component state is local, where state must be passed down from parent to child in order to access the data. It would be a good time to use Application state when a developer has a lot of child components or states to manage. 
4. Redux-thunk is an “inner function” (middleware package) that gives Redux the ability to run asynchronous operations. More specifically, it intercepts our actions dispatched by action creators and runs a dispatched API call to retrieve data before reaching to reducers. 
5. My favorite state management system by default is hooks because it is so easy to manage with such few lines of code. However, I do enjoy writing Redux code because it makes sense to centralize state and functions like reducers and actions to keep track of how everything is interacting with each other. 